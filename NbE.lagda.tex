\begin{code}[hide]
{-# OPTIONS --cubical #-}

module NbE where

open import Agda.Builtin.Char public

open import lists

infixr 20 _â‡’_
\end{code}

\section{Normalisation by Evaluation}

\subsection{A Minimal Algorithm}

We begin by defining the syntax of STLC, where we choose to work in a theory in
which the base types are parametrised by $\textsf{Char}$s:
\begin{code}
data Ty : Type where
  Base : Char â†’ Ty
  _â‡’_ : Ty â†’ Ty â†’ Ty

Ctx = ğ¶ğ‘¡ğ‘¥ Ty
Var = ğ‘‰ğ‘ğ‘Ÿ Ty
Ren = ğ‘…ğ‘’ğ‘› Ty

data Tm : Ctx â†’ Ty â†’ Type where
  V : {Î“ : Ctx} {A : Ty} â†’ Var Î“ A â†’ Tm Î“ A
  Lam : {Î“ : Ctx} {A B : Ty} (t : Tm (Î“ âŠ¹ A) B) â†’ Tm Î“ (A â‡’ B)
  App : {Î“ : Ctx} {A B : Ty} (t : Tm Î“ (A â‡’ B)) (s : Tm Î“ A) â†’ Tm Î“ B
\end{code}
\noindent
We next mutually define normal and neutral terms. Normal forms represent
$\beta$-reduced and $\eta$-long terms. We would also like to give these families
sets the structure of a presheaf on the category of renamings. (Although, as far
as normalisation is concerned, we only need to define how to rename
normals/neutrals, without proving functoriality.)
\begin{code}
data Nf : Ctx â†’ Ty â†’ Type

data Ne : Ctx â†’ Ty â†’ Type where
  NV : {Î“ : Ctx} {A : Ty} â†’ Var Î“ A â†’ Ne Î“ A
  APP : {Î“ : Ctx} {A B : Ty} â†’ Ne Î“ (A â‡’ B) â†’ Nf Î“ A â†’ Ne Î“ B

data Nf where
  NEU : {Î“ : Ctx} {X : Char} â†’ Ne Î“ (Base X) â†’ Nf Î“ (Base X)
  LAM : {Î“ : Ctx} {A B : Ty} â†’ Nf (Î“ âŠ¹ A) B â†’ Nf Î“ (A â‡’ B)

_[_]Ne : {Î” Î“ : Ctx} {A : Ty} â†’ Ne Î“ A â†’ Ren Î” Î“ â†’ Ne Î” A
_[_]Nf : {Î” Î“ : Ctx} {A : Ty} â†’ Nf Î“ A â†’ Ren Î” Î“ â†’ Nf Î” A

NV v [ Ïƒ ]Ne = NV (derive Ïƒ v)
APP M N [ Ïƒ ]Ne = APP (M [ Ïƒ ]Ne) (N [ Ïƒ ]Nf)

NEU M [ Ïƒ ]Nf = NEU (M [ Ïƒ ]Ne)
LAM {A = A} N [ Ïƒ ]Nf = LAM (N [ Wâ‚‚ğ‘…ğ‘’ğ‘› A Ïƒ ]Nf)
\end{code}
\noindent
We next define the semantic elements. The idea is that $\mathsf{El}~(\blank,A)$
is a presheaf on renamings, that, in the case of base types, is just the
presheaf of normal forms, and, at arrow types, is constructed in a universal way
from the presheaves corresponding to the domain and codomain. Again, as far as
normalisation is concerned, we can drop some data from this description. For
example, the object sets of $\mathsf{El}~(\Gamma , A \Rightarrow B)$ are
technically supposed to be sets of natural transformations, but we won't keep
track of this condition.
\begin{code}
El : Ctx â†’ Ty â†’ Type
El Î“ (Base X) = Nf Î“ (Base X)
El Î“ (A â‡’ B) = {Î” : Ctx} â†’ Ren Î” Î“ â†’ El Î” A â†’ El Î” B

_[_]El : {Î” Î“ : Ctx} {A : Ty} â†’ El Î“ A â†’ Ren Î” Î“ â†’ El Î” A
_[_]El {A = Base X} N Ïƒ = N [ Ïƒ ]Nf
_[_]El {A = A â‡’ B} ğ’» Ïƒ Ï„ ğ“ˆ = ğ’» (Ïƒ âˆ˜ğ‘…ğ‘’ğ‘› Ï„) ğ“ˆ
\end{code}
\noindent
We next define quote and unquote; these are, respectively, natural
transformations $\mathsf{El}~(\blank,A) \to \mathsf{Nf}~(\blank,A)$ and
$\mathsf{Ne}~(\blank,A) \to \mathsf{El}~(\blank,A)$, although we don't need to
prove naturality:
\begin{code}
q : {Î“ : Ctx} {A : Ty} â†’ El Î“ A â†’ Nf Î“ A
u : {Î“ : Ctx} {A : Ty} â†’ Ne Î“ A â†’ El Î“ A

q {A = Base X} N = N
q {Î“} {A â‡’ B} ğ’» = LAM (q (ğ’» (Wâ‚ğ‘…ğ‘’ğ‘› A (idğ‘…ğ‘’ğ‘› Î“)) (u (NV ğ‘§ğ‘£))))

u {A = Base X} M = NEU M
u {A = A â‡’ B} M Ïƒ ğ“ˆ = u (APP (M [ Ïƒ ]Ne) (q ğ“ˆ))
\end{code}
\noindent
We then define how to interpret a term as a presheaf morphism:
\begin{code}
eval : {Î“ Î” : Ctx} {A : Ty} â†’ Tm Î” A â†’ ğ‘‡ğ‘šğ‘  El Î“ Î” â†’ El Î“ A
eval (V v) ğ“ˆs = derive ğ“ˆs v
eval (Lam t) ğ“ˆs Ïƒ ğ“‰ = eval t (mapğ‘‡ğ‘šğ‘  _[ Ïƒ ]El ğ“ˆs âŠ• ğ“‰)
eval {Î“} (App t s) ğ“ˆs = eval t ğ“ˆs (idğ‘…ğ‘’ğ‘› Î“) (eval s ğ“ˆs)
\end{code}
\noindent
And, from this, we immediately obtain a normalisation algorithm:
\begin{code}
norm : {Î“ : Ctx} {A : Ty} â†’ Tm Î“ A â†’ Nf Î“ A
norm {Î“} t = q (eval t (mapğ‘‡ğ‘šğ‘  (Î» v â†’ u (NV v)) (idğ‘…ğ‘’ğ‘› Î“)))
\end{code}

\begin{code}[hide]
Î¹Ne : {Î“ : Ctx} {A : Ty} â†’ Ne Î“ A â†’ Tm Î“ A
Î¹Nf : {Î“ : Ctx} {A : Ty} â†’ Nf Î“ A â†’ Tm Î“ A

Î¹Ne (NV v) = V v
Î¹Ne (APP M N) = App (Î¹Ne M) (Î¹Nf N)

Î¹Nf (NEU M) = Î¹Ne M
Î¹Nf (LAM N) = Lam (Î¹Nf N)

--- Tests

ChurchType : Ty â†’ Ty
ChurchType A = (A â‡’ A) â‡’ A â‡’ A

ChurchTwo : {Î“ : Ctx} {A : Ty} â†’ Tm Î“ (ChurchType A)
ChurchTwo = Lam (Lam (App (V (ğ‘ ğ‘£ ğ‘§ğ‘£)) (App (V (ğ‘ ğ‘£ ğ‘§ğ‘£)) (V ğ‘§ğ‘£))))

PlusType : Ty â†’ Ty
PlusType A = ChurchType A â‡’ ChurchType A â‡’ ChurchType A

Plus : {Î“ : Ctx} {A : Ty} â†’ Tm Î“ (PlusType A)
Plus = Lam (Lam (Lam (Lam (App (App (V (ğ‘ ğ‘£ (ğ‘ ğ‘£ (ğ‘ ğ‘£ ğ‘§ğ‘£)))) (V (ğ‘ ğ‘£ ğ‘§ğ‘£)))
                               (App (App (V (ğ‘ ğ‘£ (ğ‘ ğ‘£ ğ‘§ğ‘£))) (V (ğ‘ ğ‘£ ğ‘§ğ‘£))) (V ğ‘§ğ‘£))))))

2+2 : Tm âˆ… (ChurchType (Base 'A'))
2+2 = Î¹Nf (norm (App (App Plus ChurchTwo) ChurchTwo))
\end{code}